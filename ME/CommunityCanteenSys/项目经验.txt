1. 【数据库表内容方便管理的方法】
    底层的数据管理，不要有任何约束，所有约束条件交给上层来进行正确性判断和处理

2.【类对象中定义成员经常为指针对象，而非临时对象的原因】
    C++任意对象之间交互，实际上并没有任何约束，只有在类型定义时，存在继承和信息可见性的约束，
    而使用对象交互时，通常将对象定义为指针的形式，将数据定义在堆中，采用指针的特性，可以让对象出现在任意需要使用它的位置

3. 【方便管理的数据表中数据，需要有序展示时的排序规则】
    无约束数据库表数据的排序方法一般有两种，
    1. 按正整数排序，每次插入最大数+1的数字 2. 按时间排序，依赖时间的线性持续增加不可逆的规则【自然】
    两种排序数据的应用场景不同，单纯用于排序不需要排序的数据输出时，使用方法一
    需要排序数据输出时，使用方法二

4. remove(i)将i移除后，将后面的元素填充i位置，因此i位置变换为新元素，
    因此，当i需要被移除且移除后，i不能被移动；i不被移除时，i才能移动

5. 类中的成员对象制造为临时对象/指针对象，主要取决于该对象是否与其他类之间存在关系【只属于该类，使用对象，否则使用指针对象】
    临时对象，只属于该类，且只在该类中使用
    一维指针对象，不改变指针内容指向，内容可能交给不同类之间互相使用
    二维指针对象，其他类的一维指针可能改变指向，当其改变时二维指针的内容判断等数据需要同步被修改

6. 类中的指针成员，在构造列表时，原则上应该将他们都设置为null或者其应该初始化的数值

7. Qt的界面之间通过指针实现界面之间的嵌套组合，
    1. show，hidden会将所有组合一起调用
    2. 空指针代表窗体为顶层窗体
    3. 窗体之间组合后会将原窗体容器释放掉，直接载入父窗体中，因此嵌套后需要继续展示原窗体样式时，需要同类型窗体嵌套设计
        【比如showBar的按钮样式，必须在QWidget内再嵌套一个QWidget，设计内部的widget】

8. 一个其余窗口是否需要不被控制、一个窗口关闭后是否new空间被释放内存

9. 类内的指针初始化必须为null或者某个具体值，否则delete时释放空区域会异常退出
    二维指针不释放，只释放其一维指针的数据【类对象的构造过程和释放的过程是相反的，很大程度影响了成员释放问题的理解】

10. Qt窗口new出来的不能自己在信号槽中delete掉，此时对象还存在，被释放掉会出问题
    【一般在对象不被使用时delete，或者使用Qt::WA_DeleteOnClose对窗口的setAttribute属性设置，在结束时调用close即可】